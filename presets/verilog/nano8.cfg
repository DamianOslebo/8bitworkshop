; Architecture file for the NANO8

; default output format is a memory initialization file
.outfmt mif

; mif file is this big
.mifwords 256
.mifwidth 8

; Opcodes for core instruction set
.define A	0
.define B	1
.define IP	2
.define NOP	3

.define ADD	8

;  ALU A + B -> dest
mova  2 { 00 (0) 0000 }
movb  2 { 00 (0) 0001 }
inc   2 { 00 (0) 0010 }
dec   2 { 00 (0) 0011 }
or    2 { 00 (0) 0100 }
and   2 { 00 (0) 0101 }
xor   2 { 00 (0) 0110 }
zero  2 { 00 (0) 0111 }
add   2 { 00 (0) 1000 }
sub   2 { 00 (0) 1001 }
asl   2 { 00 (0) 1010 }
lsr   2 { 00 (0) 1011 }
adc   2 { 00 (0) 1100 }
sbb   2 { 00 (0) 1101 }
rol   2 { 00 (0) 1110 }
ror   2 { 00 (0) 1111 }

; ALU A + immediate -> dest
movi  2 8 { 01 (0) 0001 (1) }
ori   2 8 { 01 (0) 0100 (1) }
andi  2 8 { 01 (0) 0101 (1) }
xori  2 8 { 01 (0) 0110 (1) }
addi  2 8 { 01 (0) 1000 (1) }
subi  2 8 { 01 (0) 1001 (1) }
asli  2 8 { 01 (0) 1010 (1) }
lsri  2 8 { 01 (0) 1011 (1) }
adci  2 8 { 01 (0) 1100 (1) }
sbbi  2 8 { 01 (0) 1101 (1) }
roli  2 8 { 01 (0) 1110 (1) }
rori  2 8 { 01 (0) 1111 (1) }

; ALU A + read [B] -> dest
movrb  2 { 11 (0) 0001 }
orrb   2 { 11 (0) 0100 }
andrb  2 { 11 (0) 0101 }
xorrb  2 { 11 (0) 0110 }
addrb  2 { 11 (0) 1000 }
subrb  2 { 11 (0) 1001 }
aslrb  2 { 11 (0) 1010 }
lsrrb  2 { 11 (0) 1011 }
adcrb  2 { 11 (0) 1100 }
sbbrb  2 { 11 (0) 1101 }
rolrb  2 { 11 (0) 1110 }
rorrb  2 { 11 (0) 1111 }

; A -> write [nnnn]
sta	4 { 1001 (0) }

; other insns
clc	{ 10001000 }
swapab	{ 10000001 }
reset	{ 10001111 }

lda	8 { 01 00 0001 (0) }
ldb	8 { 01 01 0001 (0) }
jmp	8 { 01 10 0001 (0) }

; conditional branch
bcc	8 { 1010 0001 (0) }
bcs	8 { 1010 0011 (0) }
bz	8 { 1010 0100 (0) }
bnz	8 { 1010 1100 (0) }


; allow raw byte positioning
byte 8  { (0)            } ; One byte constant
